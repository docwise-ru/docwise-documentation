"use strict";
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __setFunctionName = (this && this.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Extension = exports.AlgoliaProgram = void 0;
const program_1 = require("@diplodoc/cli/lib/program");
const cli_1 = require("@diplodoc/cli");
const config_1 = require("@diplodoc/cli/lib/config");
const run_1 = require("@diplodoc/cli/lib/run");
const lodash_1 = require("lodash");
const provider_1 = require("./core/provider");
const config_2 = require("./config");
const API_LINK = '_search/api.js';
class AlgoliaRun extends run_1.Run {
    constructor(config) {
        super(config);
        this.scopes.set('input', config.input);
    }
}
let AlgoliaProgram = (() => {
    let _classDecorators = [(0, program_1.withConfigDefaults)(() => ({
            search: {
                appId: process.env.ALGOLIA_APP_ID || '',
                apiKey: process.env.ALGOLIA_API_KEY || '',
                indexName: process.env.ALGOLIA_INDEX_NAME || '',
            },
        }))];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _classSuper = program_1.BaseProgram;
    var AlgoliaProgram = _classThis = class extends _classSuper {
        constructor() {
            super(...arguments);
            this.name = 'index';
            this.command = new config_1.Command(this.name)
                .description('Upload documentation index to Algolia')
                .helpOption(true)
                .allowUnknownOption(false);
            this.options = Object.values(config_2.options);
            this.modules = [];
        }
        async action(args) {
            const config = this.validateAndGetConfig(args);
            this.logger.info('Starting Algolia indexing...', config.indexName);
            this.run = new AlgoliaRun(this.config);
            const provider = this.createProvider(config);
            try {
                await provider.addObjects();
                this.logger.info('Algolia indexing completed successfully');
            }
            catch (error) {
                this.logger.error('Failed to upload index objects to Algolia:', error);
                throw error;
            }
        }
        validateAndGetConfig(args) {
            const { input } = args;
            if (!input) {
                throw new Error('Input path is required');
            }
            const appId = (0, lodash_1.get)(this.config, 'search.appId') || (0, lodash_1.get)(this.config, 'appId');
            const apiKey = (0, lodash_1.get)(this.config, 'search.apiKey') || (0, lodash_1.get)(this.config, 'apiKey');
            const indexName = (0, lodash_1.get)(this.config, 'search.indexName') || (0, lodash_1.get)(this.config, 'indexName') || 'docs';
            if (!appId || !apiKey || !indexName) {
                throw new Error('Algolia configuration is incomplete. Please provide appId, apiKey and indexName either through environment variables or command line options.');
            }
            return { appId, apiKey, indexName };
        }
        createProvider(config) {
            const { appId, apiKey, indexName } = config;
            return new provider_1.AlgoliaProvider(this.run, {
                appId,
                apiKey,
                indexName,
                index: true,
            });
        }
    };
    __setFunctionName(_classThis, "AlgoliaProgram");
    (() => {
        var _a;
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create((_a = _classSuper[Symbol.metadata]) !== null && _a !== void 0 ? _a : null) : void 0;
        __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
        AlgoliaProgram = _classThis = _classDescriptor.value;
        if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        __runInitializers(_classThis, _classExtraInitializers);
    })();
    return AlgoliaProgram = _classThis;
})();
exports.AlgoliaProgram = AlgoliaProgram;
class Extension {
    apply(program) {
        this.addAlgoliaModule(program);
        if (!Extension.hooksRegistered) {
            (0, program_1.getHooks)(program).Command.tap('AlgoliaSearch', (command) => {
                command.addOption(config_2.options.appId);
                command.addOption(config_2.options.apiKey);
                command.addOption(config_2.options.indexName);
                command.addOption(config_2.options.index);
                command.addOption(config_2.options.searchApiKey);
                command.addOption(config_2.options.provider);
                command.addOption(config_2.options.api);
            });
            (0, program_1.getHooks)(program).Config.tap('AlgoliaSearch', (config, args) => {
                const configs = [args, config, config.search];
                config.search = config.search || {};
                config.search.appId = process.env.ALGOLIA_APP_ID || (0, config_1.defined)('appId', ...configs);
                config.search.apiKey =
                    process.env.ALGOLIA_API_KEY || (0, config_1.defined)('apiKey', args, ...configs);
                config.search.indexName =
                    process.env.ALGOLIA_INDEX_NAME ||
                        (0, config_1.defined)('indexName', args, ...configs) ||
                        'docs';
                config.search.searchApiKey =
                    process.env.ALGOLIA_SEARCH_API_KEY || (0, config_1.defined)('searchApiKey', args, ...configs);
                config.search.provider =
                    process.env.ALGOLIA_PROVIDER ||
                        (0, config_1.defined)('provider', args, ...configs) ||
                        'algolia';
                config.search.api =
                    process.env.ALGOLIA_API_PATH ||
                        (0, config_1.defined)('api', args, ...configs) ||
                        '_search/api.js';
                config.search.index = (0, config_1.defined)('index', args, ...configs) || false;
                return config;
            });
            this.registerBuildHooks(program);
            Extension.hooksRegistered = true;
        }
    }
    addAlgoliaModule(program) {
        var _a;
        if (program_1.BaseProgram.is(program) && program.name === 'Program') {
            (_a = program.logger) === null || _a === void 0 ? void 0 : _a.info('Adding AlgoliaProgram to Program');
            program.addModule(new AlgoliaProgram());
        }
    }
    registerBuildHooks(program) {
        (0, cli_1.getBuildHooks)(program)
            .BeforeRun.for('html')
            .tap('AlgoliaSearch', (run) => {
            (0, cli_1.getSearchHooks)(run === null || run === void 0 ? void 0 : run.search)
                .Provider.for('algolia')
                .tap('AlgoliaSearch', (_connector, config) => {
                const provider = this.createAlgoliaProvider(run, config);
                (0, cli_1.getEntryHooks)(run.entry).State.tap('AlgoliaSearch', (state) => {
                    state.search = provider.config(state.lang);
                });
                (0, cli_1.getEntryHooks)(run.entry).Page.tap('AlgoliaSearch', (template) => {
                    template.addScript(provider.config(template.lang).api, {
                        position: 'state',
                    });
                });
                return provider;
            });
        });
    }
    createAlgoliaProvider(run, config) {
        return new provider_1.AlgoliaProvider(run, {
            appId: (0, lodash_1.get)(config, 'appId', ''),
            apiKey: (0, lodash_1.get)(config, 'apiKey'),
            searchApiKey: (0, lodash_1.get)(config, 'searchApiKey'),
            indexName: (0, lodash_1.get)(config, 'indexName', 'docs'),
            api: (0, lodash_1.get)(config, 'api', API_LINK),
            index: (0, lodash_1.get)(config, 'index', false),
        });
    }
}
exports.Extension = Extension;
Extension.hooksRegistered = false;
exports.default = Extension;
//# sourceMappingURL=index.js.map