"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgoliaProvider = void 0;
const utils_1 = require("@diplodoc/cli/lib/utils");
const algoliasearch_1 = require("algoliasearch");
const path_1 = require("path");
const workers_1 = require("../workers");
const document_processor_1 = require("./document-processor");
const utils_2 = require("./utils");
class AlgoliaProvider {
    constructor(run, config) {
        this.objects = {};
        this.logger = new utils_2.IndexLogger();
        this.run = run;
        this.index = config.index === undefined ? false : Boolean(config.index);
        if (!config.appId) {
            this.logger.error('Algolia appId is not specified');
        }
        this.appId = config.appId;
        if (!config.indexName) {
            this.logger.warn('Index name (indexName) is not specified. Using default value "docs"');
        }
        this.indexName = config.indexName || 'docs';
        this.logger.info(`Using index name: ${this.indexName}`);
        this.apiKey = config.apiKey;
        this.searchApiKey = config.searchApiKey;
        this.indexSettings = config.indexSettings || {};
        this.querySettings = config.querySettings || {};
        this.apiLink = config.api || '_search/api.js';
        if (this.apiKey) {
            try {
                this.client = (0, algoliasearch_1.algoliasearch)(this.appId, this.apiKey);
                this.logger.info('Algolia client successfully initialized');
            }
            catch (error) {
                this.logger.error('Error initializing Algolia client:', error);
            }
        }
        else {
            this.logger.warn('API key not provided, Algolia client not initialized');
        }
        if (run === null || run === void 0 ? void 0 : run.logger) {
            this.logger.pipe(run.logger);
        }
        try {
            this.workerPool = new workers_1.AlgoliaWorkerPool();
            this.workerPool.initialize();
            this.logger.info('Worker pool successfully initialized');
        }
        catch (error) {
            this.logger.error('Error initializing worker pool:', error);
        }
    }
    async add(path, lang, info) {
        var _a;
        const skipHtmlExtension = (_a = this.run.config) === null || _a === void 0 ? void 0 : _a.skipHtmlExtension;
        if (!info.html) {
            return;
        }
        const { title = '', meta = {} } = info;
        if (meta.noIndex) {
            return;
        }
        if (this.workerPool) {
            this.workerPool.addTask(path, lang, info.html, title, meta, skipHtmlExtension);
        }
        else {
            this.processDocumentSync(path, lang, info.html, title, meta);
        }
    }
    async addObjects() {
        if (!this.index) {
            return;
        }
        const searchDir = (0, path_1.join)(this.run.originalInput, '_search');
        const files = await this.run.glob('*-algolia.json', { cwd: searchDir });
        for (const file of files) {
            const langMatch = file.match(/^([a-z]{2})-algolia\.json$/);
            if (!langMatch) {
                continue;
            }
            const lang = langMatch[1];
            const filePath = (0, path_1.join)(searchDir, file);
            const content = await this.run.read(filePath);
            const records = JSON.parse(content);
            const indexName = this.createIndexName(lang);
            await this.uploadRecordsToAlgolia(indexName, lang, records, utils_2.ALGOLIA_METHODS.REPLACE_ALL_OBJECTS);
        }
    }
    async clearIndex() {
        if (!this.index) {
            return;
        }
        const client = this.ensureClient();
        for (const lang of Object.keys(this.objects)) {
            const indexName = this.createIndexName(lang);
            await client.clearObjects({ indexName });
        }
    }
    async setSettings(settings) {
        if (!this.index) {
            return;
        }
        const client = this.ensureClient();
        for (const lang of Object.keys(this.objects)) {
            const indexName = this.createIndexName(lang);
            const baseLang = (0, utils_2.getBaseLang)(lang);
            await client.setSettings({
                indexName,
                indexSettings: {
                    ...utils_2.DEFAULT_INDEX_SETTINGS,
                    ...settings,
                    indexLanguages: [lang, baseLang],
                },
            });
        }
    }
    async release() {
        if (this.workerPool) {
            const results = await this.workerPool.waitForCompletion();
            for (const [lang, records] of results.entries()) {
                this.objects[lang] = this.objects[lang] || [];
                this.objects[lang].push(...records);
            }
            await this.workerPool.terminate();
        }
        for (const lang of Object.keys(this.objects)) {
            if (this.apiLink) {
                await this.run.copy((0, path_1.join)(__dirname, '../client/search.js'), (0, path_1.join)(this.run.output, this.apiLink));
            }
            const page = await this.run.search.page(lang);
            await this.run.write((0, path_1.join)(this.run.output, (0, utils_2.pageLink)(lang)), page);
            const jsonPath = (0, path_1.join)(this.run.output, '_search', `${lang}-algolia.json`);
            await this.run.write(jsonPath, JSON.stringify(this.objects[lang], null, 2));
            this.logger.info(`Created local search index: ${this.createIndexName(lang)} - ${this.objects[lang].length} records`);
            if (!this.index || !this.client) {
                continue;
            }
            const indexName = this.createIndexName(lang);
            await this.uploadRecordsToAlgolia(indexName, lang, this.objects[lang], utils_2.ALGOLIA_METHODS.SAVE_OBJECTS);
        }
    }
    config(lang) {
        var _a;
        const skipHtmlExtension = (_a = this.run.config) === null || _a === void 0 ? void 0 : _a.skipHtmlExtension;
        const url = (0, utils_2.pageLink)(lang);
        const prettyUrl = skipHtmlExtension ? (0, utils_1.shortLink)(url) : url;
        return {
            provider: 'algolia',
            api: this.apiLink,
            link: prettyUrl,
            appId: this.appId,
            indexName: this.createIndexName(lang),
            searchApiKey: this.searchApiKey,
            querySettings: this.querySettings,
        };
    }
    createIndexName(lang) {
        return `${this.indexName}-${lang}`;
    }
    ensureClient() {
        return (0, utils_2.ensureClient)(this.client);
    }
    processDocumentSync(path, lang, html, title, meta) {
        var _a;
        const skipHtmlExtension = (_a = this.run.config) === null || _a === void 0 ? void 0 : _a.skipHtmlExtension;
        const records = (0, document_processor_1.processDocument)({ path, lang, html, title, meta, skipHtmlExtension });
        this.objects[lang] = this.objects[lang] || [];
        this.objects[lang].push(...records);
    }
    async uploadRecordsToAlgolia(indexName, lang, records, method = utils_2.ALGOLIA_METHODS.REPLACE_ALL_OBJECTS) {
        const client = (0, utils_2.ensureClient)(this.client);
        await (0, utils_2.uploadRecordsToAlgolia)(client, indexName, lang, records, method, utils_2.DEFAULT_INDEX_SETTINGS, this.indexSettings, this.logger);
    }
}
exports.AlgoliaProvider = AlgoliaProvider;
//# sourceMappingURL=provider.js.map