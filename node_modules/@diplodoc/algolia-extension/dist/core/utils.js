"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_INDEX_SETTINGS = exports.IndexLogger = exports.ALGOLIA_METHODS = void 0;
exports.getBaseLang = getBaseLang;
exports.pageLink = pageLink;
exports.uploadRecordsToAlgolia = uploadRecordsToAlgolia;
exports.ensureClient = ensureClient;
const lodash_1 = require("lodash");
const logger_1 = require("@diplodoc/cli/lib/logger");
const path_1 = require("path");
exports.ALGOLIA_METHODS = {
    REPLACE_ALL_OBJECTS: 'replaceAllObjects',
    SAVE_OBJECTS: 'saveObjects',
};
class IndexLogger extends logger_1.Logger {
    constructor() {
        super(...arguments);
        this.index = this.topic(logger_1.LogLevel.INFO, 'INDEX');
    }
}
exports.IndexLogger = IndexLogger;
function getBaseLang(lang) {
    if (['ru', 'be', 'kz', 'ua'].includes(lang)) {
        return 'ru';
    }
    return 'en';
}
function pageLink(lang) {
    return (0, path_1.join)('_search', lang, `index.html`);
}
async function uploadRecordsToAlgolia(client, indexName, lang, records, method, defaultSettings, indexSettings, logger) {
    const baseLang = getBaseLang(lang);
    logger.info(`Uploading to Algolia: ${indexName} - ${records.length} records`);
    try {
        await client.setSettings({
            indexName,
            indexSettings: {
                ...defaultSettings,
                ...indexSettings,
                customRanking: ['asc(level)'],
                indexLanguages: (0, lodash_1.uniq)([lang, baseLang]),
            },
        });
        const result = await client[method]({
            indexName,
            objects: records,
        });
        const taskIDs = findTaskIDs(result);
        if (taskIDs.length > 0) {
            await Promise.all(taskIDs.map((taskID) => client
                .waitForTask({ indexName, taskID })
                .catch((error) => logger.warn(`Error waiting for task ${taskID}: ${error instanceof Error ? error.message : String(error)}`))));
        }
        else {
            logger.warn(`No taskID found in response for index ${indexName}`);
        }
        logger.info(`Successfully uploaded to Algolia: ${indexName} - ${records.length} records`);
    }
    catch (error) {
        logger.error(`Error updating index ${indexName}:`, error);
        throw error;
    }
}
function findTaskIDs(obj) {
    if (!obj || typeof obj !== 'object') {
        return [];
    }
    const result = [];
    const objRecord = obj;
    if ('taskID' in objRecord && typeof objRecord.taskID === 'number') {
        result.push(objRecord.taskID);
    }
    Object.values(objRecord).forEach((value) => {
        if (Array.isArray(value)) {
            value.forEach((item) => result.push(...findTaskIDs(item)));
        }
        else if (value && typeof value === 'object') {
            result.push(...findTaskIDs(value));
        }
    });
    return result;
}
function ensureClient(client) {
    if (!client) {
        throw new Error('Algolia client not initialized. Please provide an API key.');
    }
    return client;
}
exports.DEFAULT_INDEX_SETTINGS = {
    distinct: 1,
    attributeForDistinct: 'url',
};
//# sourceMappingURL=utils.js.map