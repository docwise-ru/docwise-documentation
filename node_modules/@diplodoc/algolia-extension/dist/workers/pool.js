"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgoliaWorkerPool = void 0;
const worker_threads_1 = require("worker_threads");
const path_1 = require("path");
const logger_1 = require("@diplodoc/cli/lib/logger");
class WorkerPoolLogger extends logger_1.Logger {
    constructor() {
        super(...arguments);
        this.worker = this.topic(logger_1.LogLevel.INFO, 'WORKER_POOL');
    }
}
class AlgoliaWorkerPool {
    constructor(maxWorkers = 4) {
        this.workers = [];
        this.queue = [];
        this.processing = false;
        this.results = new Map();
        this.resolvePromise = null;
        this.logger = new WorkerPoolLogger();
        this.maxWorkers = Math.max(1, Math.min(maxWorkers, require('os').cpus().length - 1));
        this.workerPath = (0, path_1.join)(__dirname, 'processor.js');
    }
    initialize() {
        const fs = require('fs');
        if (!fs.existsSync(this.workerPath)) {
            throw new Error(`Worker file not found: ${this.workerPath}`);
        }
        for (let i = 0; i < this.maxWorkers; i++) {
            const worker = this.createWorker();
            this.workers.push(worker);
        }
    }
    addTask(path, lang, html, title, meta, skipHtmlExtension) {
        const message = {
            type: 'process',
            data: {
                path,
                lang,
                html,
                title,
                meta: meta || {},
                skipHtmlExtension,
            },
        };
        this.queue.push(message);
        if (!this.processing) {
            this.startProcessing();
        }
    }
    async waitForCompletion() {
        if (this.queue.length === 0 && !this.processing) {
            return this.results;
        }
        return new Promise((resolve) => {
            this.resolvePromise = resolve;
        });
    }
    async terminate() {
        try {
            this.workers.forEach((worker) => {
                try {
                    worker.postMessage({ type: 'terminate', data: null });
                }
                catch (error) {
                    this.logger.warn(`Error sending terminate message to worker:`, error);
                }
            });
            await new Promise((resolve) => setTimeout(resolve, 100));
            await Promise.all(this.workers.map((worker) => worker.terminate()));
            this.workers = [];
        }
        catch (error) {
            this.logger.error(`Error during worker pool termination:`, error);
            this.workers = [];
        }
    }
    createWorker() {
        const worker = new worker_threads_1.Worker(this.workerPath);
        worker.on('message', (message) => {
            this.handleWorkerMessage(worker, message);
        });
        worker.on('error', (error) => {
            this.logger.error(`Worker error:`, error);
            this.replaceWorker(worker);
        });
        worker.on('exit', (code) => {
            if (code !== 0) {
                this.logger.error(`Worker exited with code ${code}`);
                this.replaceWorker(worker);
            }
        });
        return worker;
    }
    handleWorkerMessage(worker, message) {
        switch (message.type) {
            case 'result': {
                const resultMessage = message;
                const records = resultMessage.data.records;
                for (const record of records) {
                    const lang = record.lang;
                    if (!this.results.has(lang)) {
                        this.results.set(lang, []);
                    }
                    const resultsForLang = this.results.get(lang);
                    if (resultsForLang) {
                        resultsForLang.push(record);
                    }
                }
                this.processNextItem(worker);
                break;
            }
            case 'error': {
                const errorMessage = message;
                this.logger.error(`Processing error:`, errorMessage.data.message);
                this.processNextItem(worker);
                break;
            }
            default:
                this.logger.warn(`Unknown message type: ${message.type}`);
                this.processNextItem(worker);
        }
        this.checkCompletion();
    }
    replaceWorker(oldWorker) {
        const index = this.workers.indexOf(oldWorker);
        if (index !== -1) {
            this.workers.splice(index, 1);
            const newWorker = this.createWorker();
            this.workers.push(newWorker);
            this.processNextItem(newWorker);
        }
    }
    processNextItem(worker) {
        if (this.queue.length > 0) {
            const task = this.queue.shift();
            if (task) {
                try {
                    worker.postMessage(task);
                }
                catch (error) {
                    this.logger.error(`Error sending task to worker:`, error);
                    this.queue.unshift(task);
                    this.replaceWorker(worker);
                }
            }
        }
    }
    startProcessing() {
        if (this.queue.length === 0) {
            return;
        }
        this.processing = true;
        for (const worker of this.workers) {
            this.processNextItem(worker);
        }
    }
    checkCompletion() {
        if (this.queue.length === 0 && this.resolvePromise) {
            this.processing = false;
            this.resolvePromise(this.results);
            this.resolvePromise = null;
        }
    }
}
exports.AlgoliaWorkerPool = AlgoliaWorkerPool;
//# sourceMappingURL=pool.js.map